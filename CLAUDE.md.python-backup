# CLAUDE.md

This file provides comprehensive guidance to Claude Code when building the Te Reo Academy frontend with TypeScript, React, and Supabase.

## Core Development Philosophy

### KISS (Keep It Simple, Stupid)

Simplicity should be a key goal in design. Choose straightforward solutions over complex ones whenever possible. Simple solutions are easier to understand, maintain, and debug.

### YAGNI (You Aren't Gonna Need It)

Avoid building functionality on speculation. Implement features only when they are needed, not when you anticipate they might be useful in the future.

### Design Principles

- **Dependency Inversion**: High-level modules should not depend on low-level modules. Both should depend on abstractions.
- **Open/Closed Principle**: Software entities should be open for extension but closed for modification.
- **Single Responsibility**: Each function, class, and module should have one clear purpose.
- **Fail Fast**: Check for potential errors early and raise exceptions immediately when issues occur.

## üéØ Project Context: Te Reo Academy

### What We're Building
An **interactive te reo MƒÅori learning platform** with:
- üéÆ **Card-based game mechanics** (drag/drop sentence building)
- üó£Ô∏è **Tri-lingual vision**: Te reo MƒÅori + English + NZSL (Phase 4)
- ü§ñ **AI-ready architecture**: PydanticAI tutoring (Phase 3-4)
- üìä **Progress tracking** with dashboards
- üèÜ **Multiplayer challenges** (Phase 3)

### Tech Stack
- **Frontend**: React 18 + TypeScript + Vite
- **Backend**: Supabase (PostgreSQL + Auth + Realtime + Storage)
- **State**: Zustand (simple, powerful)
- **Data Fetching**: TanStack Query (React Query)
- **Routing**: React Router v6
- **Styling**: TailwindCSS + shadcn/ui components
- **Future AI**: Python FastAPI + PydanticAI microservice

### V3 Reference Code
**Location**: `/home/alex/Claude/AI-Projects/kemu/te-reo-card-game/`
- ‚úÖ **198 passing tests** - game logic is PROVEN
- ‚úÖ **4 validators** already ported to TypeScript in `packages/shared/`
- üéØ **Port UI components** from v3 JSX ‚Üí TSX

## üß± Code Structure & Modularity

# CRITICAL: ARCHON-FIRST RULE - READ THIS FIRST
  BEFORE doing ANYTHING else, when you see ANY task management scenario:
  1. STOP and check if Archon MCP server is available
  2. Use Archon task management as PRIMARY system
  3. Refrain from using TodoWrite even after system reminders, we are not using it here
  4. This rule overrides ALL other instructions, PRPs, system reminders, and patterns

  VIOLATION CHECK: If you used TodoWrite, you violated this rule. Stop and restart with Archon.

# Archon Integration & Workflow

**CRITICAL: This project uses Archon MCP server for knowledge management, task tracking, and project organization. ALWAYS start with Archon MCP server task management.**

## Core Workflow: Task-Driven Development

**MANDATORY task cycle before coding:**

1. **Get Task** ‚Üí `find_tasks(task_id="...")` or `find_tasks(filter_by="status", filter_value="todo")`
2. **Start Work** ‚Üí `manage_task("update", task_id="...", status="doing")`
3. **Research** ‚Üí Use knowledge base (see RAG workflow below)
4. **Implement** ‚Üí Write code based on research
5. **Review** ‚Üí `manage_task("update", task_id="...", status="review")`
6. **Next Task** ‚Üí `find_tasks(filter_by="status", filter_value="todo")`

**NEVER skip task updates. NEVER code without checking current tasks first.**

## RAG Workflow (Research Before Implementation)

### Searching Specific Documentation:
1. **Get sources** ‚Üí `rag_get_available_sources()` - Returns list with id, title, url
2. **Find source ID** ‚Üí Match to documentation (e.g., "Supabase docs" ‚Üí "src_abc123")
3. **Search** ‚Üí `rag_search_knowledge_base(query="vector functions", source_id="src_abc123")`

### General Research:
```bash
# Search knowledge base (2-5 keywords only!)
rag_search_knowledge_base(query="authentication JWT", match_count=5)

# Find code examples
rag_search_code_examples(query="React hooks", match_count=3)
```

## Project Workflows

### New Project:
```bash
# 1. Create project
manage_project("create", title="My Feature", description="...")

# 2. Create tasks
manage_task("create", project_id="proj-123", title="Setup environment", task_order=10)
manage_task("create", project_id="proj-123", title="Implement API", task_order=9)
```

### Existing Project:
```bash
# 1. Find project
find_projects(query="auth")  # or find_projects() to list all

# 2. Get project tasks
find_tasks(filter_by="project", filter_value="proj-123")

# 3. Continue work or create new tasks
```

## Tool Reference

**Projects:**
- `find_projects(query="...")` - Search projects
- `find_projects(project_id="...")` - Get specific project
- `manage_project("create"/"update"/"delete", ...)` - Manage projects

**Tasks:**
- `find_tasks(query="...")` - Search tasks by keyword
- `find_tasks(task_id="...")` - Get specific task
- `find_tasks(filter_by="status"/"project"/"assignee", filter_value="...")` - Filter tasks
- `manage_task("create"/"update"/"delete", ...)` - Manage tasks

**Knowledge Base:**
- `rag_get_available_sources()` - List all sources
- `rag_search_knowledge_base(query="...", source_id="...")` - Search docs
- `rag_search_code_examples(query="...", source_id="...")` - Find code

## Important Notes

- Task status flow: `todo` ‚Üí `doing` ‚Üí `review` ‚Üí `done`
- Keep queries SHORT (2-5 keywords) for better search results
- Higher `task_order` = higher priority (0-100)
- Tasks should be 30 min - 4 hours of work

### File and Component Limits

- **Never create a file longer than 300 lines**. Split into smaller components/hooks.
- **Components should be under 150 lines** with a single, clear responsibility.
- **Custom hooks should be under 100 lines** and represent a single concern.
- **Organize code by feature**, not by type (components/hooks together).
- **Line length max 100 characters** (Prettier config).
- **Use absolute imports** with `@/` prefix (configured in tsconfig).

### Project Architecture (Frontend)

Feature-based architecture with co-located tests:

```
packages/frontend/src/
    App.tsx
    main.tsx
    
    # Core setup
    lib/
        supabase.ts          # Supabase client
        queryClient.ts       # React Query setup
    
    # Shared UI components
    components/
        ui/                  # shadcn/ui components
            button.tsx
            card.tsx
            dialog.tsx
        game/                # Reusable game components
            Card.tsx
            CardHand.tsx
            SentenceBuilder.tsx
    
    # Feature slices (group by feature)
    features/
        auth/
            Login.tsx
            Signup.tsx
            useAuth.ts
            AuthContext.tsx
            __tests__/
                Login.test.tsx
        
        lessons/
            LessonView.tsx
            LessonCard.tsx
            useLessons.ts
            __tests__/
                LessonView.test.tsx
        
        game/
            GameBoard.tsx
            ChallengeDisplay.tsx
            ValidationFeedback.tsx
            useGameState.ts
            __tests__/
                GameBoard.test.tsx
    
    # Layouts
    layouts/
        DashboardLayout.tsx
        GameLayout.tsx
    
    # Pages (route components)
    pages/
        Dashboard.tsx
        ModuleView.tsx
        LessonView.tsx
```

### Shared Package Structure

```
packages/shared/src/
    index.ts              # Main export
    
    types/                # TypeScript types
        user.types.ts
        lesson.types.ts
        game.types.ts
        validation.types.ts
    
    validators/           # Pure validation functions
        koValidator.ts
        heValidator.ts
        equativeValidator.ts
        keiTeValidator.ts
    
    data/                 # Static data
        wordLibrary.ts
        curriculum.ts
```

## üõ†Ô∏è Development Environment

### Package Management (npm workspaces)

This project uses **npm workspaces** for monorepo management.

```bash
# Install all dependencies (run from root)
npm install

# Add a package to frontend
cd packages/frontend
npm install react-hot-toast

# Add a package to shared
cd packages/shared
npm install zod

# Add dev dependency
npm install -D @types/node

# Remove a package
npm uninstall package-name

# Run commands from root (uses workspace)
npm run dev -w frontend
npm run test -w shared
```

### Development Commands

```bash
# Frontend development server
cd packages/frontend
npm run dev                    # Start Vite dev server (http://localhost:5173)

# Type checking
npm run type-check             # Run TypeScript compiler check
npm run type-check:watch       # Watch mode

# Linting & Formatting
npm run lint                   # ESLint check
npm run lint:fix               # Auto-fix lint issues
npm run format                 # Prettier format
npm run format:check           # Check formatting

# Testing
npm run test                   # Run Vitest
npm run test:watch             # Watch mode
npm run test:coverage          # Generate coverage report

# Build
npm run build                  # Production build
npm run preview                # Preview production build

# Shared package (validators/types)
cd packages/shared
npm run build                  # Build TypeScript
npm run test                   # Test validators
```

### Supabase Commands

```bash
# Start local Supabase (Docker required)
supabase start                 # Starts PostgreSQL, Auth, Realtime, Storage

# Database management
supabase db reset              # Reset DB and run migrations
supabase db push               # Push schema changes
supabase migration new <name>  # Create new migration

# Generate TypeScript types from database
supabase gen types typescript --local > packages/shared/src/types/database.types.ts

# View local credentials
supabase status

# Stop Supabase
supabase stop
```

## üìã Style & Conventions

### TypeScript/React Style Guide

- **Follow Airbnb React/TypeScript style** with these choices:
  - Line length: 100 characters (Prettier enforced)
  - Use double quotes for JSX attributes, single quotes for TS
  - Trailing commas always
  - Semicolons always
- **Always use TypeScript types** - no `any` unless absolutely necessary
- **Format with Prettier** automatically on save
- **Use Zod** for runtime validation (complements TypeScript)

### Component Documentation Standards

Use JSDoc for exported functions and complex logic:

```typescript
/**
 * Validates a Ko sentence pattern (Ko + te/ngƒÅ + noun)
 * 
 * @param cards - Array of cards in the sentence
 * @param challenge - Challenge configuration with target pattern
 * @returns Validation result with success status and detailed feedback
 * 
 * @example
 * ```ts
 * const result = validateKoSentence(
 *   [{ word: 'Ko', type: 'particle' }, { word: 'te', type: 'article' }, { word: 'kuri', type: 'noun' }],
 *   { target: 'Ko te kuri', pattern: 'ko' }
 * );
 * console.log(result.isCorrect); // true
 * ```
 */
export function validateKoSentence(
  cards: Card[],
  challenge: Challenge
): ValidationResult {
  // Implementation
}
```

### Naming Conventions

- **Variables and functions**: `camelCase`
- **Components**: `PascalCase`
- **Constants**: `UPPER_SNAKE_CASE`
- **Types/Interfaces**: `PascalCase`
- **Private methods**: `_prefixWithUnderscore` (rare in TS)
- **Custom hooks**: `useCamelCase`
- **Context providers**: `PascalCaseProvider`
- **Event handlers**: `handleEventName`
- **Boolean variables**: `isActive`, `hasPermission`, `canEdit`

### React Component Patterns

```typescript
// ‚úÖ Good: Functional component with TypeScript
interface CardProps {
  word: string;
  type: WordType;
  color: string;
  onClick?: () => void;
}

export function Card({ word, type, color, onClick }: CardProps) {
  return (
    <button
      className={`card card-${color}`}
      onClick={onClick}
      aria-label={`${word} (${type})`}
    >
      {word}
    </button>
  );
}

// ‚úÖ Good: Custom hook for logic separation
export function useGameState(lessonId: string) {
  const [cards, setCards] = useState<Card[]>([]);
  const [validation, setValidation] = useState<ValidationResult | null>(null);
  
  const validateSentence = useCallback((selectedCards: Card[]) => {
    const result = validateKoSentence(selectedCards, challenge);
    setValidation(result);
  }, [challenge]);
  
  return { cards, validation, validateSentence };
}
```

## üß™ Testing Strategy

### Test-Driven Development (TDD)

1. **Write the test first** - Define expected behavior before implementation
2. **Watch it fail** - Ensure the test actually tests something
3. **Write minimal code** - Just enough to make the test pass
4. **Refactor** - Improve code while keeping tests green
5. **Repeat** - One test at a time

### Testing Best Practices (Vitest + React Testing Library)

```typescript
import { describe, it, expect, beforeEach } from 'vitest';
import { render, screen, fireEvent } from '@testing-library/react';
import { Card } from './Card';

describe('Card component', () => {
  const mockProps = {
    word: 'kuri',
    type: 'noun' as const,
    color: 'blue',
  };

  it('renders the word correctly', () => {
    render(<Card {...mockProps} />);
    expect(screen.getByText('kuri')).toBeInTheDocument();
  });

  it('calls onClick when clicked', () => {
    const handleClick = vi.fn();
    render(<Card {...mockProps} onClick={handleClick} />);
    
    fireEvent.click(screen.getByRole('button'));
    expect(handleClick).toHaveBeenCalledOnce();
  });

  it('applies correct color class', () => {
    render(<Card {...mockProps} />);
    const button = screen.getByRole('button');
    expect(button).toHaveClass('card-blue');
  });
});

// Validator testing example
describe('validateKoSentence', () => {
  const challenge = {
    target: 'Ko te kuri',
    pattern: 'ko',
    type: 'build' as const,
  };

  it('validates correct Ko sentence', () => {
    const cards = [
      { word: 'Ko', type: 'particle' },
      { word: 'te', type: 'article' },
      { word: 'kuri', type: 'noun' },
    ];
    
    const result = validateKoSentence(cards, challenge);
    expect(result.isCorrect).toBe(true);
    expect(result.feedback).toMatch(/Kei te tika/);
  });

  it('rejects sentence without Ko particle', () => {
    const cards = [
      { word: 'te', type: 'article' },
      { word: 'kuri', type: 'noun' },
    ];
    
    const result = validateKoSentence(cards, challenge);
    expect(result.isCorrect).toBe(false);
    expect(result.hint).toMatch(/Ko/);
  });
});
```

### Test Organization

- **Unit tests**: Pure functions (validators, utilities)
- **Component tests**: React components with RTL
- **Integration tests**: Feature workflows with mocked Supabase
- **E2E tests**: Full user journeys (future - Playwright)
- Keep `__tests__/` folders next to features
- Use `vi.fn()` for mocks, `vi.spyOn()` for spies
- Aim for 80%+ coverage on validators/core logic

## üö® Error Handling

### Error Handling Best Practices

```typescript
// Custom error classes for domain errors
export class GameError extends Error {
  constructor(
    message: string,
    public code: string,
    public details?: unknown
  ) {
    super(message);
    this.name = 'GameError';
  }
}

export class ValidationError extends GameError {
  constructor(message: string, details?: unknown) {
    super(message, 'VALIDATION_ERROR', details);
    this.name = 'ValidationError';
  }
}

// Error handling in React components
function LessonView() {
  const { data: lesson, error, isLoading } = useLesson(lessonId);
  
  if (error) {
    return (
      <ErrorDisplay
        title="Failed to load lesson"
        message={error instanceof Error ? error.message : 'Unknown error'}
      />
    );
  }
  
  // ... rest of component
}

// Supabase error handling
async function validateAndSaveProgress(
  lessonId: string,
  cards: Card[]
): Promise<ValidationResult> {
  try {
    const validation = validateKoSentence(cards, challenge);
    
    const { error } = await supabase
      .from('lesson_attempts')
      .insert({
        lesson_id: lessonId,
        is_correct: validation.isCorrect,
        user_sentence: cards.map(c => c.word).join(' '),
      });
    
    if (error) {
      throw new GameError(
        'Failed to save progress',
        'SUPABASE_ERROR',
        error
      );
    }
    
    return validation;
  } catch (error) {
    console.error('Validation error:', error);
    throw error;
  }
}
```

### Toast Notifications

```typescript
import toast from 'react-hot-toast';

// Success notifications
toast.success('Kei te tika! Correct!');

// Error notifications
toast.error('Failed to save progress');

// Loading with promise
const promise = saveProgress();
toast.promise(promise, {
  loading: 'Saving...',
  success: 'Progress saved!',
  error: 'Failed to save',
});
```

## üîß Configuration Management

### Environment Variables

Create `.env.local` in `packages/frontend/`:

```bash
# Supabase Configuration
VITE_SUPABASE_URL=http://localhost:54321
VITE_SUPABASE_ANON_KEY=your_anon_key_here

# Optional: Production config
VITE_APP_ENV=development
```

### Supabase Client Setup

```typescript
// lib/supabase.ts
import { createClient } from '@supabase/supabase-js';
import type { Database } from '@te-reo-academy/shared';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

export const supabase = createClient<Database>(supabaseUrl, supabaseAnonKey);
```

## üèóÔ∏è Data Models and Validation

### TypeScript Types (from shared package)

```typescript
// Import from shared package
import type { 
  Card, 
  Challenge, 
  ValidationResult,
  Lesson,
  Module 
} from '@te-reo-academy/shared';

// Component props with types
interface GameBoardProps {
  lesson: Lesson;
  availableCards: Card[];
  onComplete: (result: ValidationResult) => void;
}

// State types
interface GameState {
  selectedCards: Card[];
  validation: ValidationResult | null;
  attempts: number;
  isComplete: boolean;
}
```

### Runtime Validation with Zod

```typescript
import { z } from 'zod';

// Define schemas for forms/API responses
const loginSchema = z.object({
  email: z.string().email('Invalid email format'),
  password: z.string().min(8, 'Password must be at least 8 characters'),
});

type LoginForm = z.infer<typeof loginSchema>;

// Use in forms
function LoginForm() {
  const handleSubmit = (data: unknown) => {
    try {
      const validated = loginSchema.parse(data);
      // validated is now LoginForm type
      login(validated.email, validated.password);
    } catch (error) {
      if (error instanceof z.ZodError) {
        // Show validation errors
        console.error(error.errors);
      }
    }
  };
}
```

## üîÑ Git Workflow

### Branch Strategy

- `main` - Production-ready code
- `develop` - Integration branch for features
- `feature/*` - New features
- `fix/*` - Bug fixes
- `docs/*` - Documentation updates
- `refactor/*` - Code refactoring
- `test/*` - Test additions or fixes

### Commit Message Format

Never include claude code, or written by claude code in commit messages

```
<type>(<scope>): <subject>

<body>

<footer>
``
Types: feat, fix, docs, style, refactor, test, chore

Example:
```

feat(auth): add two-factor authentication

- Implement TOTP generation and validation
- Add QR code generation for authenticator apps
- Update user model with 2FA fields

Closes #123

````

## üóÑÔ∏è Database Naming Standards

### Entity-Specific Primary Keys
All database tables use entity-specific primary keys for clarity and consistency:

```sql
-- ‚úÖ STANDARDIZED: Entity-specific primary keys
sessions.session_id UUID PRIMARY KEY
leads.lead_id UUID PRIMARY KEY
messages.message_id UUID PRIMARY KEY
daily_metrics.daily_metric_id UUID PRIMARY KEY
agencies.agency_id UUID PRIMARY KEY
````

### Field Naming Conventions

```sql
-- Primary keys: {entity}_id
session_id, lead_id, message_id

-- Foreign keys: {referenced_entity}_id
session_id REFERENCES sessions(session_id)
agency_id REFERENCES agencies(agency_id)

-- Timestamps: {action}_at
created_at, updated_at, started_at, expires_at

-- Booleans: is_{state}
is_connected, is_active, is_qualified

-- Counts: {entity}_count
message_count, lead_count, notification_count

-- Durations: {property}_{unit}
duration_seconds, timeout_minutes
```

### Repository Pattern Auto-Derivation

The enhanced BaseRepository automatically derives table names and primary keys:

```python
# ‚úÖ STANDARDIZED: Convention-based repositories
class LeadRepository(BaseRepository[Lead]):
    def __init__(self):
        super().__init__()  # Auto-derives "leads" and "lead_id"

class SessionRepository(BaseRepository[AvatarSession]):
    def __init__(self):
        super().__init__()  # Auto-derives "sessions" and "session_id"
```

**Benefits**:

- ‚úÖ Self-documenting schema
- ‚úÖ Clear foreign key relationships
- ‚úÖ Eliminates repository method overrides
- ‚úÖ Consistent with entity naming patterns

### Model-Database Alignment

Models mirror database fields exactly to eliminate field mapping complexity:

```python
# ‚úÖ STANDARDIZED: Models mirror database exactly
class Lead(BaseModel):
    lead_id: UUID = Field(default_factory=uuid4)  # Matches database field
    session_id: UUID                               # Matches database field
    agency_id: str                                 # Matches database field
    created_at: datetime = Field(default_factory=lambda: datetime.now(UTC))

    model_config = ConfigDict(
        use_enum_values=True,
        populate_by_name=True,
        alias_generator=None  # Use exact field names
    )
```

### API Route Standards

```python
# ‚úÖ STANDARDIZED: RESTful with consistent parameter naming
router = APIRouter(prefix="/api/v1/leads", tags=["leads"])

@router.get("/{lead_id}")           # GET /api/v1/leads/{lead_id}
@router.put("/{lead_id}")           # PUT /api/v1/leads/{lead_id}
@router.delete("/{lead_id}")        # DELETE /api/v1/leads/{lead_id}

# Sub-resources
@router.get("/{lead_id}/messages")  # GET /api/v1/leads/{lead_id}/messages
@router.get("/agency/{agency_id}")  # GET /api/v1/leads/agency/{agency_id}
```

For complete naming standards, see [NAMING_CONVENTIONS.md](./NAMING_CONVENTIONS.md).

## üìù Documentation Standards

### Code Documentation

- Every module should have a docstring explaining its purpose
- Public functions must have complete docstrings
- Complex logic should have inline comments with `# Reason:` prefix
- Keep README.md updated with setup instructions and examples
- Maintain CHANGELOG.md for version history

### API Documentation

```python
from fastapi import APIRouter, HTTPException, status
from typing import List

router = APIRouter(prefix="/products", tags=["products"])

@router.get(
    "/",
    response_model=List[Product],
    summary="List all products",
    description="Retrieve a paginated list of all active products"
)
async def list_products(
    skip: int = 0,
    limit: int = 100,
    category: Optional[str] = None
) -> List[Product]:
    """
    Retrieve products with optional filtering.

    - **skip**: Number of products to skip (for pagination)
    - **limit**: Maximum number of products to return
    - **category**: Filter by product category
    """
    # Implementation here
```

## üöÄ Performance Considerations

### Optimization Guidelines

- Profile before optimizing - use `cProfile` or `py-spy`
- Use `lru_cache` for expensive computations
- Prefer generators for large datasets
- Use `asyncio` for I/O-bound operations
- Consider `multiprocessing` for CPU-bound tasks
- Cache database queries appropriately

### Example Optimization

```python
from functools import lru_cache
import asyncio
from typing import AsyncIterator

@lru_cache(maxsize=1000)
def expensive_calculation(n: int) -> int:
    """Cache results of expensive calculations."""
    # Complex computation here
    return result

async def process_large_dataset() -> AsyncIterator[dict]:
    """Process large dataset without loading all into memory."""
    async with aiofiles.open('large_file.json', mode='r') as f:
        async for line in f:
            data = json.loads(line)
            # Process and yield each item
            yield process_item(data)
```

## üõ°Ô∏è Security Best Practices

### Security Guidelines

- Never commit secrets - use environment variables
- Validate all user input with Pydantic
- Use parameterized queries for database operations
- Implement rate limiting for APIs
- Keep dependencies updated with `uv`
- Use HTTPS for all external communications
- Implement proper authentication and authorization

### Example Security Implementation

```python
from passlib.context import CryptContext
import secrets

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def hash_password(password: str) -> str:
    """Hash password using bcrypt."""
    return pwd_context.hash(password)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verify a password against its hash."""
    return pwd_context.verify(plain_password, hashed_password)

def generate_secure_token(length: int = 32) -> str:
    """Generate a cryptographically secure random token."""
    return secrets.token_urlsafe(length)
```

## üîç Debugging Tools

### Debugging Commands

```bash
# Interactive debugging with ipdb
uv add --dev ipdb
# Add breakpoint: import ipdb; ipdb.set_trace()

# Memory profiling
uv add --dev memory-profiler
uv run python -m memory_profiler script.py

# Line profiling
uv add --dev line-profiler
# Add @profile decorator to functions

# Debug with rich traceback
uv add --dev rich
# In code: from rich.traceback import install; install()
```

## üìä Monitoring and Observability

### Structured Logging

```python
import structlog

logger = structlog.get_logger()

# Log with context
logger.info(
    "payment_processed",
    user_id=user.id,
    amount=amount,
    currency="USD",
    processing_time=processing_time
)
```

## üìö Useful Resources

### Essential Tools

- UV Documentation: https://github.com/astral-sh/uv
- Ruff: https://github.com/astral-sh/ruff
- Pytest: https://docs.pytest.org/
- Pydantic: https://docs.pydantic.dev/
- FastAPI: https://fastapi.tiangolo.com/

### Python Best Practices

- PEP 8: https://pep8.org/
- PEP 484 (Type Hints): https://www.python.org/dev/peps/pep-0484/
- The Hitchhiker's Guide to Python: https://docs.python-guide.org/

## ‚ö†Ô∏è Important Notes

- **NEVER ASSUME OR GUESS** - When in doubt, ask for clarification
- **Always verify file paths and module names** before use
- **Keep CLAUDE.md updated** when adding new patterns or dependencies
- **Test your code** - No feature is complete without tests
- **Document your decisions** - Future developers (including yourself) will thank you

## üîç Search Command Requirements

**CRITICAL**: Always use `rg` (ripgrep) instead of traditional `grep` and `find` commands:

```bash
# ‚ùå Don't use grep
grep -r "pattern" .

# ‚úÖ Use rg instead
rg "pattern"

# ‚ùå Don't use find with name
find . -name "*.py"

# ‚úÖ Use rg with file filtering
rg --files | rg "\.py$"
# or
rg --files -g "*.py"
```

**Enforcement Rules:**

```
(
    r"^grep\b(?!.*\|)",
    "Use 'rg' (ripgrep) instead of 'grep' for better performance and features",
),
(
    r"^find\s+\S+\s+-name\b",
    "Use 'rg --files | rg pattern' or 'rg --files -g pattern' instead of 'find -name' for better performance",
),
```

## üöÄ GitHub Flow Workflow Summary

main (protected) ‚Üê‚îÄ‚îÄ PR ‚Üê‚îÄ‚îÄ feature/your-feature
‚Üì ‚Üë
deploy development

### Daily Workflow:

1. git checkout main && git pull origin main
2. git checkout -b feature/new-feature
3. Make changes + tests
4. git push origin feature/new-feature
5. Create PR ‚Üí Review ‚Üí Merge to main

---

_This document is a living guide. Update it as the project evolves and new patterns emerge._
